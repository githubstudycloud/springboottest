好的，让我们实现CompensationScheduler(补偿调度器)：

```java
package com.platform.collect.core.collector.compensation.scheduler;

/**
 * 补偿调度器
 */
@Slf4j
@Component
public class CompensationScheduler {

    @Autowired
    private CompensationManager compensationManager;

    @Autowired
    private CompensationRepository compensationRepository;

    // 调度配置
    @Value("${compensation.schedule.corePoolSize:5}")
    private int corePoolSize;

    @Value("${compensation.schedule.maxPoolSize:10}")
    private int maxPoolSize;

    @Value("${compensation.schedule.checkInterval:60}")
    private int checkInterval;

    // 调度执行器
    private final ScheduledExecutorService scheduler;
    private final ThreadPoolExecutor executor;

    public CompensationScheduler() {
        this.scheduler = Executors.newScheduledThreadPool(1,
            new NamedThreadFactory("compensation-scheduler-"));
            
        this.executor = new ThreadPoolExecutor(
            corePoolSize,
            maxPoolSize,
            60L,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(1000),
            new NamedThreadFactory("compensation-executor-"),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
    }

    /**
     * 启动调度器
     */
    @PostConstruct
    public void start() {
        // 定时检查待执行任务
        scheduler.scheduleWithFixedDelay(
            this::checkPendingTasks,
            0,
            checkInterval,
            TimeUnit.SECONDS
        );

        log.info("Compensation scheduler started");
    }

    /**
     * 检查待执行任务
     */
    private void checkPendingTasks() {
        try {
            // 1. 获取待执行任务
            List<CompensationTask> pendingTasks = compensationRepository.findPendingTasks();
            if (CollectionUtils.isEmpty(pendingTasks)) {
                return;
            }

            // 2. 过滤可执行任务
            List<CompensationTask> executableTasks = filterExecutableTasks(pendingTasks);
            
            // 3. 提交执行
            submitTasks(executableTasks);

        } catch (Exception e) {
            log.error("Check pending tasks failed", e);
        }
    }

    /**
     * 过滤可执行任务
     */
    private List<CompensationTask> filterExecutableTasks(List<CompensationTask> tasks) {
        return tasks.stream()
            .filter(task -> {
                // 检查延迟时间
                if (task.getDelay() > 0) {
                    long delayUntil = task.getCreateTime().getTime() + task.getDelay();
                    return System.currentTimeMillis() >= delayUntil;
                }
                return true;
            })
            .collect(Collectors.toList());
    }

    /**
     * 提交任务执行
     */
    private void submitTasks(List<CompensationTask> tasks) {
        for (CompensationTask task : tasks) {
            try {
                // 提交执行任务
                executor.submit(() -> executeTask(task));
            } catch (Exception e) {
                log.error("Submit task failed: {}", task.getTaskId(), e);
            }
        }
    }

    /**
     * 执行补偿任务
     */
    private void executeTask(CompensationTask task) {
        try {
            // 执行补偿
            compensationManager.executeCompensation(task.getTaskId());
        } catch (Exception e) {
            log.error("Execute compensation task failed: {}", task.getTaskId(), e);
        }
    }

    /**
     * 手动触发任务执行
     */
    public void triggerExecution(String taskId) {
        CompensationTask task = compensationRepository.findById(taskId);
        if (task != null) {
            executor.submit(() -> executeTask(task));
        }
    }

    /**
     * 获取调度器状态
     */
    public SchedulerStatus getStatus() {
        return SchedulerStatus.builder()
            .activeCount(executor.getActiveCount())
            .poolSize(executor.getPoolSize())
            .queueSize(executor.getQueue().size())
            .completedTaskCount(executor.getCompletedTaskCount())
            .build();
    }

    /**
     * 调度器状态
     */
    @Data
    @Builder
    public static class SchedulerStatus {
        private int activeCount;          // 活动线程数
        private int poolSize;             // 池大小
        private int queueSize;            // 队列大小
        private long completedTaskCount;   // 已完成任务数
    }

    /**
     * 关闭调度器
     */
    @PreDestroy
    public void shutdown() {
        try {
            // 关闭调度器
            scheduler.shutdown();
            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                scheduler.shutdownNow();
            }

            // 关闭执行器
            executor.shutdown();
            if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }

            log.info("Compensation scheduler stopped");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    /**
     * 获取调度指标
     */
    public SchedulerMetrics getMetrics() {
        SchedulerMetrics metrics = new SchedulerMetrics();
        
        // 线程池指标
        metrics.setActiveThreads(executor.getActiveCount());
        metrics.setPoolSize(executor.getPoolSize());
        metrics.setQueueSize(executor.getQueue().size());
        metrics.setCompletedTasks(executor.getCompletedTaskCount());
        
        // 任务执行指标
        CompensationMetrics taskMetrics = compensationRepository.getMetrics();
        metrics.setPendingTasks(taskMetrics.getPendingCount());
        metrics.setExecutingTasks(taskMetrics.getExecutingCount());
        metrics.setCompletedTasks(taskMetrics.getCompletedCount());
        metrics.setFailedTasks(taskMetrics.getFailedCount());
        metrics.setAvgExecuteTime(taskMetrics.getAvgExecuteTime());
        metrics.setAvgRetryCount(taskMetrics.getAvgRetryCount());
        
        return metrics;
    }
}
```

这个补偿调度器实现了：

1. 调度管理
    - 定时检查任务
    - 任务过滤
    - 任务提交
    - 任务执行

2. 线程管理
    - 调度线程池
    - 执行线程池
    - 资源控制
    - 生命周期管理

3. 状态监控
    - 执行状态
    - 线程池状态
    - 任务统计
    - 性能指标

4. 控制功能
    - 手动触发
    - 优雅关闭
    - 异常处理

接下来要实现CompensationService(补偿服务)吗？它提供补偿功能的服务层接口。
好的，让我们实现CompensationService(补偿服务)：

```java
package com.platform.collect.core.collector.compensation.service;

/**
 * 补偿服务接口
 */
public interface CompensationService {

    /**
     * 创建补偿任务
     */
    String createCompensation(CompensationRequest request);

    /**
     * 取消补偿任务
     */
    void cancelCompensation(String taskId);

    /**
     * 获取补偿状态
     */
    CompensationStatus getCompensationStatus(String taskId);

    /**
     * 手动触发补偿
     */
    void triggerCompensation(String taskId);

    /**
     * 获取补偿结果
     */
    CompensationResult getCompensationResult(String taskId);
}

/**
 * 补偿服务实现
 */
@Slf4j
@Service
public class CompensationServiceImpl implements CompensationService {

    @Autowired
    private CompensationManager compensationManager;

    @Autowired
    private CompensationRepository compensationRepository;

    @Autowired
    private CompensationScheduler compensationScheduler;

    @Override
    public String createCompensation(CompensationRequest request) {
        try {
            // 1. 验证请求
            validateRequest(request);

            // 2. 构建补偿任务
            CompensationTask task = buildCompensationTask(request);

            // 3. 创建补偿
            String taskId = compensationManager.createCompensation(task);

            // 4. 记录操作日志
            recordOperationLog("CREATE", taskId, null);

            return taskId;

        } catch (Exception e) {
            log.error("Create compensation failed", e);
            throw new CompensationException("Create compensation failed: " + e.getMessage(), e);
        }
    }

    @Override
    public void cancelCompensation(String taskId) {
        try {
            // 1. 获取任务
            CompensationTask task = getTask(taskId);

            // 2. 检查是否可取消
            if (!isCancellable(task)) {
                throw new IllegalStateException("Task is not cancellable: " + taskId);
            }

            // 3. 执行取消
            task.setStatus(CompensationStatus.FAILED);
            task.setError("Cancelled by user");
            compensationRepository.save(task);

            // 4. 记录操作日志
            recordOperationLog("CANCEL", taskId, null);

        } catch (Exception e) {
            log.error("Cancel compensation failed: {}", taskId, e);
            throw new CompensationException("Cancel compensation failed: " + e.getMessage(), e);
        }
    }

    @Override
    public CompensationStatus getCompensationStatus(String taskId) {
        try {
            CompensationTask task = getTask(taskId);
            return task.getStatus();
        } catch (Exception e) {
            log.error("Get compensation status failed: {}", taskId, e);
            throw new CompensationException("Get status failed: " + e.getMessage(), e);
        }
    }

    @Override
    public void triggerCompensation(String taskId) {
        try {
            // 1. 获取任务
            CompensationTask task = getTask(taskId);

            // 2. 检查是否可触发
            if (!isTriggerable(task)) {
                throw new IllegalStateException("Task is not triggerable: " + taskId);
            }

            // 3. 触发执行
            compensationScheduler.triggerExecution(taskId);

            // 4. 记录操作日志
            recordOperationLog("TRIGGER", taskId, null);

        } catch (Exception e) {
            log.error("Trigger compensation failed: {}", taskId, e);
            throw new CompensationException("Trigger compensation failed: " + e.getMessage(), e);
        }
    }

    @Override
    public CompensationResult getCompensationResult(String taskId) {
        try {
            // 1. 获取任务
            CompensationTask task = getTask(taskId);

            // 2. 获取执行结果
            return buildCompensationResult(task);

        } catch (Exception e) {
            log.error("Get compensation result failed: {}", taskId, e);
            throw new CompensationException("Get result failed: " + e.getMessage(), e);
        }
    }

    /**
     * 验证补偿请求
     */
    private void validateRequest(CompensationRequest request) {
        if (StringUtils.isEmpty(request.getType())) {
            throw new IllegalArgumentException("Compensation type is required");
        }
        if (StringUtils.isEmpty(request.getResourceId())) {
            throw new IllegalArgumentException("Resource id is required");
        }
    }

    /**
     * 构建补偿任务
     */
    private CompensationTask buildCompensationTask(CompensationRequest request) {
        return CompensationTask.builder()
            .type(request.getType())
            .resourceId(request.getResourceId())
            .params(request.getParams())
            .delay(request.getDelay())
            .maxRetries(request.getMaxRetries())
            .build();
    }

    /**
     * 检查是否可取消
     */
    private boolean isCancellable(CompensationTask task) {
        return task.getStatus() == CompensationStatus.PENDING ||
               task.getStatus() == CompensationStatus.EXECUTING;
    }

    /**
     * 检查是否可触发
     */
    private boolean isTriggerable(CompensationTask task) {
        return task.getStatus() == CompensationStatus.PENDING ||
               task.getStatus() == CompensationStatus.FAILED;
    }

    /**
     * 构建补偿结果
     */
    private CompensationResult buildCompensationResult(CompensationTask task) {
        CompensationResult.CompensationResultBuilder builder = CompensationResult.builder();
        
        switch (task.getStatus()) {
            case COMPLETED:
                builder.success(true);
                break;
            case FAILED:
                builder.success(false)
                    .message(task.getError());
                break;
            default:
                builder.success(false)
                    .message("Task is not completed: " + task.getStatus());
        }
        
        return builder.build();
    }

    /**
     * 记录操作日志
     */
    private void recordOperationLog(String operation, String taskId, String detail) {
        try {
            OperationLog log = OperationLog.builder()
                .operation(operation)
                .taskId(taskId)
                .detail(detail)
                .operator(getCurrentUser())
                .timestamp(new Date())
                .build();
            
            operationLogService.saveLog(log);
        } catch (Exception e) {
            log.error("Record operation log failed", e);
        }
    }

    /**
     * 获取补偿任务
     */
    private CompensationTask getTask(String taskId) {
        CompensationTask task = compensationRepository.findById(taskId);
        if (task == null) {
            throw new TaskNotFoundException("Compensation task not found: " + taskId);
        }
        return task;
    }
}
```

这个补偿服务实现了：

1. 基本功能
    - 创建补偿任务
    - 取消补偿任务
    - 触发补偿执行
    - 查询补偿状态

2. 请求处理
    - 参数验证
    - 任务构建
    - 状态检查
    - 结果构建

3. 异常处理
    - 异常封装
    - 错误处理
    - 状态验证

4. 日志记录
    - 操作日志
    - 错误日志
    - 追踪记录

要继续实现CompensationController(补偿控制器)吗？它提供补偿功能的REST API接口。