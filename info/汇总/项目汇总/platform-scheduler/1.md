我将帮你重写platform-scheduler模块。让我们从表结构设计开始。

首先创建所需的数据库表:



```sql
-- 任务定义表
CREATE TABLE job_definition (
    id VARCHAR(50) NOT NULL COMMENT '任务ID',
    name VARCHAR(100) NOT NULL COMMENT '任务名称',
    description VARCHAR(500) COMMENT '任务描述',  
    job_type VARCHAR(20) NOT NULL COMMENT '任务类型:HTTP/SHELL等',
    cron_expression VARCHAR(100) COMMENT 'CRON表达式',
    fixed_delay BIGINT COMMENT '固定延迟(毫秒)',
    timeout BIGINT COMMENT '超时时间(毫秒)',
    max_retries INT DEFAULT 0 COMMENT '最大重试次数',
    retry_interval BIGINT DEFAULT 0 COMMENT '重试间隔(毫秒)',
    job_data TEXT COMMENT '任务数据(JSON格式)',
    status VARCHAR(20) NOT NULL DEFAULT 'CREATED' COMMENT '任务状态',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (id),
    INDEX idx_status (status),
    INDEX idx_create_time (create_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='任务定义表';

-- 任务执行表
CREATE TABLE job_execution (
    id VARCHAR(50) NOT NULL COMMENT '执行ID',
    job_id VARCHAR(50) NOT NULL COMMENT '任务ID',
    node_id VARCHAR(50) NOT NULL COMMENT '执行节点ID',
    start_time DATETIME NOT NULL COMMENT '开始时间',
    end_time DATETIME COMMENT '结束时间',
    status VARCHAR(20) NOT NULL COMMENT '执行状态',
    result TEXT COMMENT '执行结果',
    error TEXT COMMENT '错误信息',
    retry_count INT DEFAULT 0 COMMENT '重试次数',
    trace_id VARCHAR(50) COMMENT '链路追踪ID', 
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (id),
    INDEX idx_job_id (job_id),
    INDEX idx_status (status),
    INDEX idx_start_time (start_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='任务执行表';

-- 任务日志表
CREATE TABLE job_log (
    id VARCHAR(50) NOT NULL COMMENT '日志ID',
    execution_id VARCHAR(50) NOT NULL COMMENT '执行ID',
    job_id VARCHAR(50) NOT NULL COMMENT '任务ID',
    log_type VARCHAR(20) NOT NULL COMMENT '日志类型',
    content TEXT NOT NULL COMMENT '日志内容',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    PRIMARY KEY (id),
    INDEX idx_execution_id (execution_id),
    INDEX idx_job_id (job_id),
    INDEX idx_create_time (create_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='任务日志表';

-- 任务锁表
CREATE TABLE job_lock (
    lock_key VARCHAR(100) NOT NULL COMMENT '锁键',
    node_id VARCHAR(50) NOT NULL COMMENT '持有节点',
    expires_at DATETIME NOT NULL COMMENT '过期时间',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (lock_key),
    INDEX idx_expires_at (expires_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='任务锁表';

-- 任务模板表
CREATE TABLE job_template (
    id VARCHAR(50) NOT NULL COMMENT '模板ID',
    name VARCHAR(100) NOT NULL COMMENT '模板名称',
    description VARCHAR(500) COMMENT '模板描述',
    template_content TEXT NOT NULL COMMENT '模板内容',
    variables TEXT COMMENT '变量定义',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='任务模板表';

-- 监控指标表 
CREATE TABLE metrics_record (
    id VARCHAR(50) NOT NULL COMMENT '记录ID',
    metrics_name VARCHAR(100) NOT NULL COMMENT '指标名称',
    metrics_value DECIMAL(20,4) NOT NULL COMMENT '指标值',
    node_id VARCHAR(50) COMMENT '节点ID',
    tags JSON COMMENT '标签',
    collect_time DATETIME NOT NULL COMMENT '采集时间',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    PRIMARY KEY (id),
    INDEX idx_metrics_name (metrics_name),
    INDEX idx_collect_time (collect_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='监控指标表';

-- 告警记录表
CREATE TABLE alert_record (
    id VARCHAR(50) NOT NULL COMMENT '告警ID',
    alert_name VARCHAR(100) NOT NULL COMMENT '告警名称',
    alert_level VARCHAR(20) NOT NULL COMMENT '告警级别',
    content TEXT NOT NULL COMMENT '告警内容',
    status VARCHAR(20) NOT NULL COMMENT '告警状态',
    node_id VARCHAR(50) COMMENT '告警节点',
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (id),
    INDEX idx_alert_name (alert_name),
    INDEX idx_status (status),
    INDEX idx_create_time (create_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='告警记录表';

```

接下来是pom.xml文件:



```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>platform-parent</artifactId>
        <groupId>com.study</groupId>
        <version>1.0.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>platform-scheduler</artifactId>

    <dependencies>
        <!-- Spring Boot -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.mariadb.jdbc</groupId>
            <artifactId>mariadb-java-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>${mybatis.version}</version>
        </dependency>

        <!-- Redis -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.redisson</groupId>
            <artifactId>redisson-spring-boot-starter</artifactId>
            <version>3.23.0</version>
        </dependency>

        <!-- RabbitMQ -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>

        <!-- Quartz -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-quartz</artifactId>
        </dependency>

        <!-- Common -->
        <dependency>
            <groupId>com.study</groupId>
            <artifactId>platform-common</artifactId>
            <version>${project.version}</version>
        </dependency>

        <!-- Tools -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
        </dependency>
        <dependency> 
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-jsr310</artifactId>
        </dependency>

        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <mainClass>com.study.scheduler.SchedulerApplication</mainClass>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>repackage</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>

```

下面是主要的配置文件application.yml:



```yaml
server:
  port: 8081

spring:
  application:
    name: platform-scheduler

  # DataSource
  datasource:
    driver-class-name: org.mariadb.jdbc.Driver
    url: jdbc:mariadb://localhost:3306/scheduler?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
    username: root
    password: 123456
    type: com.zaxxer.hikari.HikariDataSource
    hikari:
      minimum-idle: 5
      maximum-pool-size: 15
      idle-timeout: 30000
      pool-name: SchedulerHikariCP
      max-lifetime: 1800000
      connection-timeout: 30000
      connection-test-query: SELECT 1

  # Redis
  data:
    redis:
      password: 123456
      timeout: 5000
      lettuce:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 0
          max-wait: 1000
      cluster:
        nodes:
          - 127.0.0.1:6379
          - 127.0.0.1:6380
          - 127.0.0.1:6381

  # RabbitMQ
  rabbitmq:
    host: localhost
    port: 5672
    username: admin
    password: 123456
    virtual-host: /
    publisher-confirms: true
    publisher-returns: true
    listener:
      simple:
        acknowledge-mode: manual
        prefetch: 1
        concurrency: 3
        max-concurrency: 10
        retry:
          enabled: true
          initial-interval: 1000ms
          max-attempts: 3
          multiplier: 2

  # Quartz
  quartz:
    job-store-type: jdbc
    jdbc:
      initialize-schema: always
    properties:
      org.quartz.scheduler.instanceName: QuartzScheduler
      org.quartz.scheduler.instanceId: AUTO
      org.quartz.jobStore.class: org.springframework.scheduling.quartz.LocalDataSourceJobStore
      org.quartz.jobStore.driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate
      org.quartz.jobStore.tablePrefix: QRTZ_
      org.quartz.jobStore.isClustered: true
      org.quartz.jobStore.clusterCheckinInterval: 10000
      org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool
      org.quartz.threadPool.threadCount: 10
      org.quartz.threadPool.threadPriority: 5

# MyBatis
mybatis:
  mapper-locations: classpath:mapper/*.xml
  configuration:
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl

# Scheduler Config
scheduler:
  cluster:
    enabled: true
    node-id: ${HOSTNAME:node-1}
  execution:
    pool:
      core-size: 10
      max-size: 20
      queue-capacity: 50
      keep-alive: 300
  retry:
    max-attempts: 3
    initial-interval: 1000
    multiplier: 2.0
    max-interval: 10000
  monitor:
    metrics-interval: 60
    cleanup-interval: 86400

# Management
management:
  endpoints:
    web:
      exposure:
        include: health
```

好的,让我们按照项目结构开始输出代码。从api层开始:

1. 首先创建API层的Controller:



```java
package com.study.scheduler.api.controller.job;

import com.study.common.util.Result;
import com.study.scheduler.api.model.request.job.*;
import com.study.scheduler.api.model.vo.job.*;
import com.study.scheduler.domain.service.JobDomainService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Slf4j
@RestController
@RequestMapping("/api/jobs")
public class JobController {

    @Autowired
    private JobDomainService jobDomainService;

    @PostMapping
    public Result<JobVO> createJob(@Validated @RequestBody JobCreateRequest request) {
        log.info("Creating job: {}", request);
        JobVO job = jobDomainService.createJob(request);
        return Result.success(job);
    }

    @PutMapping("/{id}")
    public Result<JobVO> updateJob(@PathVariable String id, 
            @Validated @RequestBody JobUpdateRequest request) {
        log.info("Updating job {}: {}", id, request);
        JobVO job = jobDomainService.updateJob(id, request);
        return Result.success(job);
    }

    @DeleteMapping("/{id}")
    public Result<Void> deleteJob(@PathVariable String id) {
        log.info("Deleting job: {}", id);
        jobDomainService.deleteJob(id);
        return Result.success();
    }

    @GetMapping("/{id}")
    public Result<JobDetailVO> getJob(@PathVariable String id) {
        JobDetailVO job = jobDomainService.getJobDetail(id);
        return Result.success(job);
    }

    @GetMapping
    public Result<List<JobVO>> queryJobs(JobQueryRequest request) {
        List<JobVO> jobs = jobDomainService.queryJobs(request);
        return Result.success(jobs);
    }

    @GetMapping("/{id}/logs")
    public Result<List<JobLogVO>> getJobLogs(@PathVariable String id) {
        List<JobLogVO> logs = jobDomainService.getJobLogs(id);
        return Result.success(logs);
    }

    @PostMapping("/{id}/pause")
    public Result<Void> pauseJob(@PathVariable String id) {
        log.info("Pausing job: {}", id);
        jobDomainService.pauseJob(id);
        return Result.success();
    }

    @PostMapping("/{id}/resume") 
    public Result<Void> resumeJob(@PathVariable String id) {
        log.info("Resuming job: {}", id);
        jobDomainService.resumeJob(id);
        return Result.success();
    }
}

```



```java
package com.study.scheduler.api.controller.job;

import com.study.common.util.Result;
import com.study.scheduler.api.model.request.job.JobExecuteRequest;
import com.study.scheduler.core.executor.ExecuteResult;
import com.study.scheduler.domain.service.ExecutionDomainService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

@Slf4j
@RestController
@RequestMapping("/api/jobs/execute")
public class JobExecuteController {

    @Autowired
    private ExecutionDomainService executionService;

    @PostMapping("/{id}")
    public Result<ExecuteResult> executeJob(@PathVariable String id, 
            @Validated @RequestBody JobExecuteRequest request) {
        log.info("Executing job {}: {}", id, request);
        ExecuteResult result = executionService.executeJob(id, request);
        return Result.success(result);
    }

    @PostMapping("/{id}/stop")
    public Result<Void> stopJob(@PathVariable String id) {
        log.info("Stopping job execution: {}", id);
        executionService.stopJob(id);
        return Result.success();
    }

    @PostMapping("/{id}/retry")
    public Result<ExecuteResult> retryJob(@PathVariable String id) {
        log.info("Retrying job: {}", id);
        ExecuteResult result = executionService.retryJob(id);
        return Result.success(result);
    }

    @GetMapping("/{id}/status")
    public Result<String> getJobStatus(@PathVariable String id) {
        String status = executionService.getJobStatus(id);
        return Result.success(status);
    }
}

```

现在让我继续输出JobRegisterController和JobTemplateController的代码?好的，继续输出Controller层的代码：



```java
package com.study.scheduler.api.controller.job;

import com.study.common.util.Result;
import com.study.scheduler.api.model.request.job.JobRegisterRequest;
import com.study.scheduler.api.model.vo.job.JobVO;
import com.study.scheduler.core.manager.JobManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Slf4j
@RestController
@RequestMapping("/api/jobs/register")
public class JobRegisterController {

    @Autowired
    private JobManager jobManager;

    @PostMapping
    public Result<JobVO> registerJob(@Validated @RequestBody JobRegisterRequest request) {
        log.info("Registering new job: {}", request);
        JobVO job = jobManager.registerJob(request);
        return Result.success(job);
    }

    @PostMapping("/batch")
    public Result<List<JobVO>> batchRegister(@Validated @RequestBody List<JobRegisterRequest> requests) {
        log.info("Batch registering {} jobs", requests.size());
        List<JobVO> jobs = jobManager.batchRegisterJobs(requests);
        return Result.success(jobs);
    }

    @PutMapping("/{id}/enable")
    public Result<Void> enableJob(@PathVariable String id) {
        log.info("Enabling job: {}", id);
        jobManager.enableJob(id);
        return Result.success();
    }

    @PutMapping("/{id}/disable") 
    public Result<Void> disableJob(@PathVariable String id) {
        log.info("Disabling job: {}", id);
        jobManager.disableJob(id);
        return Result.success();
    }

    @GetMapping("/types")
    public Result<List<String>> getJobTypes() {
        List<String> types = jobManager.getSupportedJobTypes();
        return Result.success(types);
    }
}

```



```java
package com.study.scheduler.api.controller.job;

import com.study.common.util.Result;
import com.study.scheduler.api.model.request.job.JobTemplateRequest;
import com.study.scheduler.api.model.vo.job.JobTemplateVO;
import com.study.scheduler.api.model.vo.job.JobVO;
import com.study.scheduler.core.manager.JobTemplateManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@Slf4j
@RestController
@RequestMapping("/api/jobs/templates")
public class JobTemplateController {

    @Autowired
    private JobTemplateManager templateManager;

    @PostMapping
    public Result<JobTemplateVO> createTemplate(@Validated @RequestBody JobTemplateRequest request) {
        log.info("Creating job template: {}", request);
        JobTemplateVO template = templateManager.createTemplate(request);
        return Result.success(template);
    }

    @PutMapping("/{id}")
    public Result<JobTemplateVO> updateTemplate(@PathVariable String id,
            @Validated @RequestBody JobTemplateRequest request) {
        log.info("Updating job template {}: {}", id, request);
        JobTemplateVO template = templateManager.updateTemplate(id, request);
        return Result.success(template);
    }

    @DeleteMapping("/{id}")
    public Result<Void> deleteTemplate(@PathVariable String id) {
        log.info("Deleting job template: {}", id);
        templateManager.deleteTemplate(id);
        return Result.success();
    }

    @GetMapping("/{id}")
    public Result<JobTemplateVO> getTemplate(@PathVariable String id) {
        JobTemplateVO template = templateManager.getTemplate(id);
        return Result.success(template);
    }

    @GetMapping
    public Result<List<JobTemplateVO>> listTemplates() {
        List<JobTemplateVO> templates = templateManager.listTemplates();
        return Result.success(templates);
    }

    @PostMapping("/{id}/apply")
    public Result<JobVO> applyTemplate(
            @PathVariable String id,
            @RequestBody Map<String, Object> variables) {
        log.info("Applying template {} with variables: {}", id, variables);
        JobVO job = templateManager.applyTemplate(id, variables);
        return Result.success(job);
    }

    @GetMapping("/{id}/variables")
    public Result<Map<String, String>> getTemplateVariables(@PathVariable String id) {
        Map<String, String> variables = templateManager.getTemplateVariables(id);
        return Result.success(variables);
    }
}

```

接下来是监控相关的Controller:



```java
package com.study.scheduler.api.controller.monitor;

import com.study.common.util.Result;
import com.study.scheduler.api.model.request.monitor.MetricsRequest;
import com.study.scheduler.api.model.vo.monitor.MetricsVO;
import com.study.scheduler.core.manager.MetricsManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@Slf4j
@RestController
@RequestMapping("/api/monitor/metrics")
public class MetricsController {

    @Autowired
    private MetricsManager metricsManager;

    @GetMapping("/system")
    public Result<Map<String, Object>> getSystemMetrics() {
        Map<String, Object> metrics = metricsManager.getSystemMetrics();
        return Result.success(metrics);
    }

    @GetMapping("/job")
    public Result<List<MetricsVO>> getJobMetrics(MetricsRequest request) {
        List<MetricsVO> metrics = metricsManager.getJobMetrics(request);
        return Result.success(metrics);
    }

    @GetMapping("/node")
    public Result<List<MetricsVO>> getNodeMetrics(MetricsRequest request) {
        List<MetricsVO> metrics = metricsManager.getNodeMetrics(request);
        return Result.success(metrics);
    }

    @GetMapping("/execution")
    public Result<Map<String, Long>> getExecutionMetrics() {
        Map<String, Long> metrics = metricsManager.getExecutionMetrics();
        return Result.success(metrics);
    }

    @GetMapping("/{jobId}/history")
    public Result<List<MetricsVO>> getJobMetricsHistory(
            @PathVariable String jobId,
            @RequestParam String metric,
            @RequestParam Long startTime,
            @RequestParam Long endTime) {
        List<MetricsVO> metrics = metricsManager.getJobMetricsHistory(
                jobId, metric, startTime, endTime);
        return Result.success(metrics);
    }
}

```

需要我继续输出AlertController和SystemController吗？好的，继续输出监控告警和系统管理相关的Controller：



```java
package com.study.scheduler.api.controller.monitor;

import com.study.common.util.Result;
import com.study.scheduler.api.model.request.monitor.AlertRequest;
import com.study.scheduler.api.model.vo.monitor.AlertVO;
import com.study.scheduler.core.manager.AlertManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Slf4j
@RestController
@RequestMapping("/api/monitor/alerts")
public class AlertController {

    @Autowired
    private AlertManager alertManager;

    @PostMapping("/rules")
    public Result<Void> createAlertRule(@Validated @RequestBody AlertRequest request) {
        log.info("Creating alert rule: {}", request);
        alertManager.createAlertRule(request);
        return Result.success();
    }

    @GetMapping("/rules")
    public Result<List<AlertVO>> getAlertRules() {
        List<AlertVO> rules = alertManager.getAlertRules();
        return Result.success(rules);
    }

    @GetMapping("/active")
    public Result<List<AlertVO>> getActiveAlerts() {
        List<AlertVO> alerts = alertManager.getActiveAlerts();
        return Result.success(alerts);
    }

    @GetMapping("/history")
    public Result<List<AlertVO>> getAlertHistory(
            @RequestParam(required = false) String level,
            @RequestParam(required = false) Long startTime,
            @RequestParam(required = false) Long endTime) {
        List<AlertVO> alerts = alertManager.getAlertHistory(level, startTime, endTime);
        return Result.success(alerts);
    }

    @PostMapping("/{id}/acknowledge")
    public Result<Void> acknowledgeAlert(@PathVariable String id) {
        log.info("Acknowledging alert: {}", id);
        alertManager.acknowledgeAlert(id);
        return Result.success();
    }

    @PostMapping("/{id}/resolve")
    public Result<Void> resolveAlert(@PathVariable String id) {
        log.info("Resolving alert: {}", id);
        alertManager.resolveAlert(id);
        return Result.success();
    }

    @DeleteMapping("/rules/{id}")
    public Result<Void> deleteAlertRule(@PathVariable String id) {
        log.info("Deleting alert rule: {}", id);
        alertManager.deleteAlertRule(id);
        return Result.success();
    }
}

```



```java
package com.study.scheduler.api.controller.admin;

import com.study.common.util.Result;
import com.study.scheduler.core.manager.SystemManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@Slf4j
@RestController
@RequestMapping("/api/admin/system")
public class SystemController {

    @Autowired
    private SystemManager systemManager;

    @GetMapping("/nodes")
    public Result<List<Map<String, Object>>> getClusterNodes() {
        List<Map<String, Object>> nodes = systemManager.getClusterNodes();
        return Result.success(nodes);
    }

    @GetMapping("/config")
    public Result<Map<String, Object>> getSystemConfig() {
        Map<String, Object> config = systemManager.getSystemConfig();
        return Result.success(config);
    }

    @PutMapping("/config")
    public Result<Void> updateSystemConfig(@RequestBody Map<String, Object> config) {
        log.info("Updating system config: {}", config);
        systemManager.updateSystemConfig(config);
        return Result.success();
    }

    @PostMapping("/nodes/{nodeId}/offline")
    public Result<Void> offlineNode(@PathVariable String nodeId) {
        log.info("Taking node offline: {}", nodeId);
        systemManager.offlineNode(nodeId);
        return Result.success();
    }

    @PostMapping("/nodes/{nodeId}/online")
    public Result<Void> onlineNode(@PathVariable String nodeId) {
        log.info("Bringing node online: {}", nodeId);
        systemManager.onlineNode(nodeId);
        return Result.success();
    }

    @GetMapping("/status")
    public Result<Map<String, Object>> getSystemStatus() {
        Map<String, Object> status = systemManager.getSystemStatus();
        return Result.success(status);
    }

    @PostMapping("/maintenance/start")
    public Result<Void> startMaintenance() {
        log.info("Starting system maintenance mode");
        systemManager.startMaintenanceMode();
        return Result.success();
    }

    @PostMapping("/maintenance/stop")
    public Result<Void> stopMaintenance() {
        log.info("Stopping system maintenance mode");
        systemManager.stopMaintenanceMode();
        return Result.success();
    }

    @PostMapping("/cache/clear")
    public Result<Void> clearCache(@RequestParam(required = false) String type) {
        log.info("Clearing system cache, type: {}", type);
        systemManager.clearCache(type);
        return Result.success();
    }
}

```

现在我们开始实现API层的请求和响应模型。我先实现任务相关的请求模型：



```java
package com.study.scheduler.api.model.request.job;

import lombok.Data;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.util.Map;

@Data
public class JobCreateRequest {
    @NotBlank(message = "Job name cannot be empty")
    private String name;
    
    private String description;
    
    @NotBlank(message = "Job type cannot be empty")
    private String jobType;
    
    private String cronExpression;
    
    private Long fixedDelay;
    
    private Long timeout;
    
    private Integer maxRetries;
    
    private Long retryInterval;
    
    private Map<String, Object> jobData;
}

@Data
public class JobUpdateRequest {
    private String name;
    private String description;
    private String cronExpression;
    private Long fixedDelay;
    private Long timeout;
    private Integer maxRetries;
    private Long retryInterval;
    private Map<String, Object> jobData;
}

@Data
public class JobQueryRequest {
    private String name;
    private String jobType;
    private String status;
    private Long startTime;
    private Long endTime;
    private Integer page;
    private Integer size;
}

@Data 
public class JobExecuteRequest {
    private Map<String, Object> parameters;
    private Boolean async = false;
    private Long timeout;
}

@Data
public class JobRegisterRequest extends JobCreateRequest {
    @NotNull(message = "Whether to enable job must be specified")
    private Boolean enabled = true;
    
    private Boolean replace = false;
}

@Data
public class BatchJobRequest {
    @NotNull(message = "Job list cannot be null")
    private List<JobCreateRequest> jobs;
}

```

需要我继续实现模板请求和监控告警相关的请求模型吗？