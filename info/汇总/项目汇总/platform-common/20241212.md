我来设计platform-common模块的扩展内容。



```java
package com.study.common.util;

import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.TimeUnit;
import java.util.function.Supplier;

/**
 * 分布式锁工具类
 */
public class DistributedLockUtil {
    private static final Logger logger = LoggerFactory.getLogger(DistributedLockUtil.class);
    private static final String LOCK_PREFIX = "distributed_lock:";
    private static final long DEFAULT_WAIT_TIME = 5;
    private static final long DEFAULT_LEASE_TIME = 30;

    private final RedissonClient redissonClient;

    public DistributedLockUtil(RedissonClient redissonClient) {
        this.redissonClient = redissonClient;
    }

    /**
     * 获取锁并执行
     *
     * @param lockKey 锁键
     * @param supplier 执行函数
     * @return 执行结果
     */
    public <T> T executeWithLock(String lockKey, Supplier<T> supplier) {
        return executeWithLock(lockKey, DEFAULT_WAIT_TIME, DEFAULT_LEASE_TIME, supplier);
    }

    /**
     * 获取锁并执行,支持自定义等待和租约时间
     *
     * @param lockKey 锁键
     * @param waitTime 等待时间(秒)
     * @param leaseTime 租约时间(秒)
     * @param supplier 执行函数
     * @return 执行结果
     */
    public <T> T executeWithLock(String lockKey, long waitTime, long leaseTime, Supplier<T> supplier) {
        String fullLockKey = LOCK_PREFIX + lockKey;
        RLock lock = redissonClient.getLock(fullLockKey);
        boolean locked = false;
        
        try {
            locked = lock.tryLock(waitTime, leaseTime, TimeUnit.SECONDS);
            if (!locked) {
                throw new RuntimeException("Failed to acquire lock: " + fullLockKey);
            }
            
            logger.debug("Acquired lock: {}", fullLockKey);
            return supplier.get();
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Thread interrupted while acquiring lock", e);
        } finally {
            if (locked) {
                lock.unlock();
                logger.debug("Released lock: {}", fullLockKey);
            }
        }
    }

    /**
     * 尝试获取锁
     */
    public boolean tryLock(String lockKey) {
        return tryLock(lockKey, DEFAULT_WAIT_TIME, DEFAULT_LEASE_TIME);
    }

    /**
     * 尝试获取锁,支持自定义等待和租约时间
     */
    public boolean tryLock(String lockKey, long waitTime, long leaseTime) {
        String fullLockKey = LOCK_PREFIX + lockKey;
        RLock lock = redissonClient.getLock(fullLockKey);
        
        try {
            return lock.tryLock(waitTime, leaseTime, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        }
    }

    /**
     * 释放锁
     */
    public void unlock(String lockKey) {
        String fullLockKey = LOCK_PREFIX + lockKey;
        RLock lock = redissonClient.getLock(fullLockKey);
        
        if (lock != null && lock.isHeldByCurrentThread()) {
            lock.unlock();
            logger.debug("Released lock: {}", fullLockKey);
        }
    }
}

```

```java
package com.study.common.util;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

import java.util.UUID;
import java.util.function.Supplier;

/**
 * 链路追踪工具类
 */
public class TaskTraceUtil {
    private static final Logger logger = LoggerFactory.getLogger(TaskTraceUtil.class);
    private static final String TRACE_ID = "traceId";
    private static final String SPAN_ID = "spanId";
    private static final String PARENT_SPAN_ID = "parentSpanId";

    /**
     * 生成追踪ID
     */
    public static String generateTraceId() {
        return UUID.randomUUID().toString().replace("-", "");
    }

    /**
     * 生成Span ID
     */
    public static String generateSpanId() {
        return Long.toHexString(UUID.randomUUID().getMostSignificantBits());
    }

    /**
     * 开始追踪
     */
    public static void startTrace() {
        startTrace(generateTraceId());
    }

    /**
     * 使用指定的追踪ID开始追踪
     */
    public static void startTrace(String traceId) {
        MDC.put(TRACE_ID, traceId);
        MDC.put(SPAN_ID, generateSpanId());
    }

    /**
     * 开始新的Span
     */
    public static String startSpan() {
        String parentSpanId = MDC.get(SPAN_ID);
        String newSpanId = generateSpanId();
        MDC.put(PARENT_SPAN_ID, parentSpanId);
        MDC.put(SPAN_ID, newSpanId);
        return newSpanId;
    }

    /**
     * 结束当前Span
     */
    public static void endSpan() {
        String parentSpanId = MDC.get(PARENT_SPAN_ID);
        if (parentSpanId != null) {
            MDC.put(SPAN_ID, parentSpanId);
        }
        MDC.remove(PARENT_SPAN_ID);
    }

    /**
     * 清理追踪上下文
     */
    public static void clearTrace() {
        MDC.clear();
    }

    /**
     * 在追踪上下文中执行
     */
    public static <T> T executeWithTrace(Supplier<T> supplier) {
        boolean isNewTrace = MDC.get(TRACE_ID) == null;
        if (isNewTrace) {
            startTrace();
        }
        
        try {
            return supplier.get();
        } finally {
            if (isNewTrace) {
                clearTrace();
            }
        }
    }

    /**
     * 获取当前追踪ID
     */
    public static String currentTraceId() {
        return MDC.get(TRACE_ID);
    }

    /**
     * 获取当前Span ID
     */
    public static String currentSpanId() {
        return MDC.get(SPAN_ID);
    }
}

```

```java
package com.study.common.model.task;

import lombok.Data;
import lombok.Builder;
import java.util.Date;
import java.util.Map;
import java.util.List;

/**
 * 任务定义
 */
@Data
@Builder
public class TaskDefinition {
    private String id;
    private String name;
    private String description;
    private TaskType type;
    private String cronExpression;
    private HttpConfig httpConfig;
    private List<String> variables;
    private Integer priority;
    private RetryPolicy retryPolicy;
    private TaskStatus status;
    private Date createTime;
    private Date updateTime;
}

/**
 * HTTP配置
 */
@Data
@Builder
public class HttpConfig {
    private String url;
    private String method;
    private Map<String, String> headers;
    private String body;
    private Map<String, String> parameters;
}

/**
 * 重试策略
 */
@Data
@Builder
public class RetryPolicy {
    private int maxRetries;
    private long retryInterval;
    private boolean exponentialBackoff;
}

/**
 * 任务执行记录
 */
@Data
@Builder
public class TaskExecution {
    private String id;
    private String taskDefId;
    private String traceId;
    private TaskStatus status;
    private Date startTime;
    private Date endTime;
    private Long duration;
    private String result;
    private String error;
    private String nodeInfo;
    private Integer retryCount;
}

/**
 * 任务状态
 */
public enum TaskStatus {
    CREATED,
    WAITING,
    RUNNING,
    COMPLETED,
    FAILED,
    STOPPED,
    SKIPPED
}

/**
 * 任务类型
 */
public enum TaskType {
    SCHEDULED,
    HTTP,
    CUSTOM
}

/**
 * 任务结果
 */
@Data
@Builder
public class TaskResult {
    private boolean success;
    private String message;
    private Object data;
    private Long cost;
}

```

```java
package com.study.common.util;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 变量处理工具类
 */
public class VariableUtil {
    private static final Logger logger = LoggerFactory.getLogger(VariableUtil.class);
    private static final String VARIABLE_PREFIX = "${";
    private static final String VARIABLE_SUFFIX = "}";

    private static final Map<String, VariableProvider> providers = new ConcurrentHashMap<>();

    /**
     * 注册变量提供者
     */
    public static void registerProvider(String providerName, VariableProvider provider) {
        providers.put(providerName, provider);
        logger.info("Registered variable provider: {}", providerName);
    }

    /**
     * 解析变量
     */
    public static String resolveVariable(String text) {
        if (text == null || !text.contains(VARIABLE_PREFIX)) {
            return text;
        }

        String result = text;
        int startIndex;
        int endIndex;

        while ((startIndex = result.indexOf(VARIABLE_PREFIX)) >= 0 
               && (endIndex = result.indexOf(VARIABLE_SUFFIX, startIndex)) >= 0) {
            
            String variable = result.substring(startIndex + VARIABLE_PREFIX.length(), endIndex);
            String[] parts = variable.split(":", 2);
            String providerName = parts[0];
            String key = parts.length > 1 ? parts[1] : "";

            VariableProvider provider = providers.get(providerName);
            if (provider != null) {
                String value = provider.getVariableValue(key);
                if (value != null) {
                    result = result.substring(0, startIndex) + value 
                            + result.substring(endIndex + VARIABLE_SUFFIX.length());
                }
            } else {
                logger.warn("Variable provider not found: {}", providerName);
            }
        }

        return result;
    }

    /**
     * 解析Map中的所有变量
     */
    public static Map<String, String> resolveVariables(Map<String, String> map) {
        Map<String, String> result = new ConcurrentHashMap<>();
        map.forEach((k, v) -> result.put(k, resolveVariable(v)));
        return result;
    }
}

/**
 * 变量提供者接口
 */
public interface VariableProvider {
    String getVariableValue(String key);
}

```

这些工具类和模型的主要功能:

1. DistributedLockUtil
- 提供分布式锁操作封装
- 支持可重入锁
- 提供锁超时和自动释放机制
- 支持函数式调用

2. TaskTraceUtil
- 提供全链路追踪能力
- 支持Trace和Span概念
- 集成MDC日志
- 提供上下文传递

3. 任务相关模型
- 统一的任务定义模型
- HTTP任务配置模型
- 重试策略模型
- 任务执行记录模型
- 完整的任务状态定义

4. VariableUtil
- 变量解析和替换功能
- 支持多个变量提供者
- 支持默认值
- 批量变量处理

使用示例:

```java
// 使用分布式锁
DistributedLockUtil lockUtil = new DistributedLockUtil(redissonClient);
String result = lockUtil.executeWithLock("taskKey", () -> {
    // 业务逻辑
    return "success";
});

// 使用链路追踪
TaskTraceUtil.executeWithTrace(() -> {
    String traceId = TaskTraceUtil.currentTraceId();
    // 业务逻辑
    return null;
});

// 使用变量工具
VariableUtil.registerProvider("token", new TokenVariableProvider());
String resolved = VariableUtil.resolveVariable("${token:access}");
```

后续我们需要:
1. 添加这些类的单元测试
2. 在现有服务中整合这些工具类
3. 完善配置和文档

您觉得这个设计如何?我们可以继续讨论具体的实现细节。