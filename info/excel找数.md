我来帮你写一个Excel公式来实现这个功能。

假设K列包含我们要搜索的数据范围(比如K2:K100)，我们要找第一个大于B2的值，可以使用以下公式:

```
=INDEX(K2:K100,MATCH(TRUE,K2:K100>B2,0))
```

这个公式的工作原理是:
1. K2:K100>B2 会创建一个TRUE/FALSE数组，标记哪些值大于B2
2. MATCH(TRUE,...,0) 会找到第一个TRUE的位置
3. INDEX则会返回该位置的实际值

或者也可以使用数组公式(按Ctrl+Shift+Enter输入):
```
=SMALL(IF(K2:K100>B2,K2:K100,""),1)
```

这个公式会:
1. 找出所有大于B2的值
2. 从中取最小的一个(即第一个大于B2的值)

如果你希望返回这个值在K列中的位置(行号)，可以使用:
```
=MATCH(TRUE,K2:K100>B2,0)+1
```

这些公式都假设K列的数据是按顺序排列的。你需要根据实际数据范围调整K2:K100这个区域。

你想用哪种方式实现？我可以根据你的具体需求进一步调整公式。
如果显示#N/A错误，可能是因为在K列中没有找到大于B2的值。让我们用IFERROR函数来处理这种情况：

```
=IFERROR(INDEX(K:K,MATCH(TRUE,K:K>B2,0)),"未找到大于B2的值")
```

这个公式会：
1. 当找到符合条件的值时显示该值
2. 当没找到时，显示"未找到大于B2的值"（这个提示文字你可以改成你想要的）

如果还是有问题，可以检查：
1. B2单元格是否包含数值
2. K列的值是否都是数值格式
3. K列是否有大于B2的值

你可以先用简单的公式测试一下：
```
=K1>B2
```
把这个复制到几个单元格，看看比较结果是否正确。这样可以帮助找出问题所在。让我们检查下数据类型。把数值的格式统一一下：

1. 先检查B2的格式：选中B2单元格，右键 -> 设置单元格格式，看是否是"数值"

2. 同样检查K列的格式：选中K列数据，右键 -> 设置单元格格式，改为"数值"

有可能你的数据虽然看起来是数字，但实际上是文本格式。可以用这个公式测试：
```
=ISNUMBER(B2)  
```
和
```
=ISNUMBER(K1)
```

如果返回FALSE，说明是文本格式。

试试这个修改后的公式，强制转换为数值：
```
=IFERROR(INDEX(K:K,MATCH(TRUE,VALUE(K:K)>VALUE(B2),0)),"未找到")
```

或者更简单地，先把你的数据全选，按Alt + H + N + 5 将文本转为数值，然后再用原来的公式：
```
=IFERROR(INDEX(K:K,MATCH(TRUE,K:K>B2,0)),"未找到")
```


让我们一步步排查问题：

1. 首先，用最简单的方式测试比较是否正常工作。在一个空单元格中输入：
```
=K1>B2
```
然后把这个公式往下拖动几行，看看是否能正确显示TRUE/FALSE

2. 如果上面的测试也显示有问题，我们可以试试强制转换数字类型的公式：
```
=IFERROR(INDEX(K:K,MATCH(TRUE,--K:K>--B2,0)),"未找到")
```

3. 或者用这个更直观的公式（不需要按Ctrl+Shift+Enter）：
```
=LOOKUP(2,1/(K:K>B2),K:K)
```

你能帮我做这个测试吗？就是第1步那个简单的比较，看看结果如何？这样我们能知道问题出在哪里。

另外，你也可以告诉我K列中具体写的是哪些数字，让我帮你检查是否有其他问题。啊，明白了！是的，MINIFS是在 Excel 2016 之后才有的函数。

对于 Excel 2013，我们可以用这些兼容的公式：

```
=SMALL(IF(K1:K13>B2,K1:K13),1)
```
这个是数组公式，输入后需要按 Ctrl+Shift+Enter。

或者用这个普通公式：
```
=LOOKUP(2,1/(K1:K13>B2),K1:K13)
```

或者最基础的：
```
=INDEX(K1:K13,MATCH(TRUE,K1:K13>B2,0))
```

这些都是 Excel 2013 支持的函数，应该能帮你找到K列中第一个大于B2的值。你试试看哪个能用？

如果还不行，我们可以用 MIN 和 IF 的组合来实现，但会稍微复杂一点。
LOOKUP 确实是从后往前找的特点。让我们用 INDEX + AGGREGATE，这个是从前往前找：

```
=INDEX(K1:K7,AGGREGATE(15,6,ROW(K1:K7)/(K1:K7>B2),1))
```

或者用最简单的方式，把 LOOKUP 改成从小到大找：
```
=LOOKUP(B2+0.00001,K1:K7,K1:K7)
```

这样加一个很小的数，就能找到严格大于B2的第一个值。

比如：
- 如果B2是2
- K列有1,2,3,4
- 那么B2+0.00001就是2.00001
- 函数会返回3，因为3是第一个大于2.00001的值

你试试看这两个公式哪个更符合你的需求？让我详细解释这个公式的每个部分：

```
=INDEX(K1:K7,AGGREGATE(15,6,ROW(K1:K7)/(K1:K7>B2),1))
```

1. AGGREGATE函数的参数含义：
    - 15：表示使用SMALL函数，即找最小值。这是固定的，如果想找最大值用14(LARGE)
    - 6：表示忽略错误值。这基本是固定用法，因为除法可能产生错误
    - ROW(K1:K7)/(K1:K7>B2)：生成行号，当K1:K7>B2为TRUE时保留行号，FALSE时因为除以0会产生错误被忽略
    - 1：表示要第1个符合条件的值。如果要第2个就写2，以此类推

2. 整个公式的工作过程：
    - K1:K7>B2 产生TRUE/FALSE数组
    - ROW(K1:K7)生成行号1,2,3,4,5,6,7
    - 除法运算后，保留满足条件的行号
    - AGGREGATE找出最小的行号
    - INDEX根据这个行号返回K列对应的值

所以15,6,1这三个数字中：
- 15是固定的(除非你想用LARGE找最大的)
- 6是固定的(用于忽略错误)
- 1是可变的(取第几个符合条件的值)