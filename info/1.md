package com.study.scheduler.config;

import org.apache.http.HeaderElement;
import org.apache.http.HeaderElementIterator;
import org.apache.http.HttpResponse;
import org.apache.http.conn.ConnectionKeepAliveStrategy;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.apache.http.message.BasicHeaderElementIterator;
import org.apache.http.protocol.HTTP;
import org.apache.http.protocol.HttpContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;

import java.util.concurrent.TimeUnit;

@Configuration
@EnableScheduling
public class HttpClientConfig {
private static final Logger logger = LoggerFactory.getLogger(HttpClientConfig.class);

    private static final int MAX_TOTAL_CONNECTIONS = 100;
    private static final int DEFAULT_MAX_PER_ROUTE = 20;
    private static final int VALIDATE_AFTER_INACTIVITY = 2000;
    private static final int DEFAULT_KEEP_ALIVE_TIME = 20000;
    private static final int IDLE_CONNECTION_WAIT_TIME = 30;

    @Bean
    public PoolingHttpClientConnectionManager poolingConnectionManager() {
        PoolingHttpClientConnectionManager poolingConnectionManager = new PoolingHttpClientConnectionManager();
        
        // 最大连接数
        poolingConnectionManager.setMaxTotal(MAX_TOTAL_CONNECTIONS);
        // 每个路由的最大连接数
        poolingConnectionManager.setDefaultMaxPerRoute(DEFAULT_MAX_PER_ROUTE);
        // 验证连接是否可用的间隔时间
        poolingConnectionManager.setValidateAfterInactivity(VALIDATE_AFTER_INACTIVITY);
        
        return poolingConnectionManager;
    }

    @Bean
    public ConnectionKeepAliveStrategy connectionKeepAliveStrategy() {
        return new ConnectionKeepAliveStrategy() {
            @Override
            public long getKeepAliveDuration(HttpResponse response, HttpContext context) {
                HeaderElementIterator it = new BasicHeaderElementIterator(
                    response.headerIterator(HTTP.CONN_KEEP_ALIVE));
                
                while (it.hasNext()) {
                    HeaderElement he = it.nextElement();
                    String param = he.getName();
                    String value = he.getValue();
                    
                    if (value != null && param.equalsIgnoreCase("timeout")) {
                        return Long.parseLong(value) * 1000;
                    }
                }
                return DEFAULT_KEEP_ALIVE_TIME;
            }
        };
    }

    @Bean
    public CloseableHttpClient httpClient() {
        return HttpClients.custom()
            .setConnectionManager(poolingConnectionManager())
            .setKeepAliveStrategy(connectionKeepAliveStrategy())
            .setRetryHandler((exception, executionCount, context) -> {
                if (executionCount > 3) {
                    return false;
                }
                // 如果服务器丢掉了连接，那么就重试
                if (exception instanceof NoHttpResponseException) {
                    return true;
                }
                return false;
            })
            .build();
    }

    @Bean
    public Runnable idleConnectionMonitor(final PoolingHttpClientConnectionManager connectionManager) {
        return new Runnable() {
            @Override
            @Scheduled(fixedDelay = 10000)
            public void run() {
                try {
                    if (connectionManager != null) {
                        logger.trace("Closing expired and idle connections...");
                        // 关闭过期连接
                        connectionManager.closeExpiredConnections();
                        // 关闭空闲连接
                        connectionManager.closeIdleConnections(IDLE_CONNECTION_WAIT_TIME, TimeUnit.SECONDS);
                    }
                } catch (Exception e) {
                    logger.error("Exception occurred during closing connections", e);
                }
            }
        };
    }
}这个问题通常与 HTTP 连接池的配置和管理有关。NoHttpResponseException 在高并发场景下常见，主要可能是以下原因导致：

1. 服务器端关闭了空闲连接（连接被提前回收）
2. 连接池配置不合理
3. 网络问题导致连接重置

让我来帮你写一个优化的 HttpClient 配置：



```java
package com.study.scheduler.config;

import org.apache.http.HeaderElement;
import org.apache.http.HeaderElementIterator;
import org.apache.http.HttpResponse;
import org.apache.http.conn.ConnectionKeepAliveStrategy;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.apache.http.message.BasicHeaderElementIterator;
import org.apache.http.protocol.HTTP;
import org.apache.http.protocol.HttpContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;

import java.util.concurrent.TimeUnit;

@Configuration
@EnableScheduling
public class HttpClientConfig {
    private static final Logger logger = LoggerFactory.getLogger(HttpClientConfig.class);
    
    private static final int MAX_TOTAL_CONNECTIONS = 100;
    private static final int DEFAULT_MAX_PER_ROUTE = 20;
    private static final int VALIDATE_AFTER_INACTIVITY = 2000;
    private static final int DEFAULT_KEEP_ALIVE_TIME = 20000;
    private static final int IDLE_CONNECTION_WAIT_TIME = 30;

    @Bean
    public PoolingHttpClientConnectionManager poolingConnectionManager() {
        PoolingHttpClientConnectionManager poolingConnectionManager = new PoolingHttpClientConnectionManager();
        
        // 最大连接数
        poolingConnectionManager.setMaxTotal(MAX_TOTAL_CONNECTIONS);
        // 每个路由的最大连接数
        poolingConnectionManager.setDefaultMaxPerRoute(DEFAULT_MAX_PER_ROUTE);
        // 验证连接是否可用的间隔时间
        poolingConnectionManager.setValidateAfterInactivity(VALIDATE_AFTER_INACTIVITY);
        
        return poolingConnectionManager;
    }

    @Bean
    public ConnectionKeepAliveStrategy connectionKeepAliveStrategy() {
        return new ConnectionKeepAliveStrategy() {
            @Override
            public long getKeepAliveDuration(HttpResponse response, HttpContext context) {
                HeaderElementIterator it = new BasicHeaderElementIterator(
                    response.headerIterator(HTTP.CONN_KEEP_ALIVE));
                
                while (it.hasNext()) {
                    HeaderElement he = it.nextElement();
                    String param = he.getName();
                    String value = he.getValue();
                    
                    if (value != null && param.equalsIgnoreCase("timeout")) {
                        return Long.parseLong(value) * 1000;
                    }
                }
                return DEFAULT_KEEP_ALIVE_TIME;
            }
        };
    }

    @Bean
    public CloseableHttpClient httpClient() {
        return HttpClients.custom()
            .setConnectionManager(poolingConnectionManager())
            .setKeepAliveStrategy(connectionKeepAliveStrategy())
            .setRetryHandler((exception, executionCount, context) -> {
                if (executionCount > 3) {
                    return false;
                }
                // 如果服务器丢掉了连接，那么就重试
                if (exception instanceof NoHttpResponseException) {
                    return true;
                }
                return false;
            })
            .build();
    }

    @Bean
    public Runnable idleConnectionMonitor(final PoolingHttpClientConnectionManager connectionManager) {
        return new Runnable() {
            @Override
            @Scheduled(fixedDelay = 10000)
            public void run() {
                try {
                    if (connectionManager != null) {
                        logger.trace("Closing expired and idle connections...");
                        // 关闭过期连接
                        connectionManager.closeExpiredConnections();
                        // 关闭空闲连接
                        connectionManager.closeIdleConnections(IDLE_CONNECTION_WAIT_TIME, TimeUnit.SECONDS);
                    }
                } catch (Exception e) {
                    logger.error("Exception occurred during closing connections", e);
                }
            }
        };
    }
}

```

这个配置做了以下优化：

1. 连接池管理：
    - 设置了最大连接数（100）和每个路由最大连接数（20）
    - 定期验证连接是否可用（2秒）
    - 配置了连接存活时间（20秒）

2. 重试机制：
    - 对 NoHttpResponseException 异常进行重试
    - 最大重试次数为3次

3. 连接保活策略：
    - 实现了自定义的 KeepAliveStrategy
    - 可以根据服务器返回的 keep-alive 超时时间来设置

4. 空闲连接管理：
    - 每10秒运行一次清理任务
    - 关闭过期的连接
    - 关闭超过30秒的空闲连接

使用建议：

1. 根据实际并发量调整 MAX_TOTAL_CONNECTIONS 和 DEFAULT_MAX_PER_ROUTE
2. 如果服务端的超时设置较短，可以相应调整 DEFAULT_KEEP_ALIVE_TIME
3. 使用时注意释放连接：

```java
try (CloseableHttpResponse response = httpClient.execute(request)) {
    // 处理响应
} catch (IOException e) {
    logger.error("Error executing request", e);
}
```

如果还是遇到问题，可以：

1. 增加日志记录，监控连接池的使用情况
2. 考虑增加连接超时和读取超时时间
3. 如果是特定服务器的问题，可以针对该服务器单独配置更大的连接数

需要注意的是，有时候这个问题也可能是服务器端的问题，建议也检查服务器端的配置：

1. 检查服务器的最大连接数设置
2. 检查服务器的 keep-alive 超时设置
3. 检查服务器的负载均衡策略我来帮你改造成静态工具类，同时保持连接池的优化配置：

```java
package com.study.scheduler.utils;

import org.apache.http.HeaderElement;
import org.apache.http.HeaderElementIterator;
import org.apache.http.HttpEntity;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.conn.ConnectionKeepAliveStrategy;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.apache.http.message.BasicHeaderElementIterator;
import org.apache.http.protocol.HTTP;
import org.apache.http.protocol.HttpContext;
import org.apache.http.util.EntityUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.PreDestroy;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.TimeUnit;

public class HttpClientUtil {
    private static final Logger logger = LoggerFactory.getLogger(HttpClientUtil.class);

    private static final CloseableHttpClient httpClient;
    private static final PoolingHttpClientConnectionManager connectionManager;

    // 连接池配置
    private static final int MAX_TOTAL_CONNECTIONS = 100;
    private static final int DEFAULT_MAX_PER_ROUTE = 20;
    private static final int VALIDATE_AFTER_INACTIVITY = 2000;
    private static final int DEFAULT_KEEP_ALIVE_TIME = 20000;

    // 请求配置
    private static final RequestConfig DEFAULT_REQUEST_CONFIG = RequestConfig.custom()
            .setConnectTimeout(5000)
            .setSocketTimeout(10000)
            .setConnectionRequestTimeout(3000)
            .build();

    // 静态初始化
    static {
        connectionManager = new PoolingHttpClientConnectionManager();
        connectionManager.setMaxTotal(MAX_TOTAL_CONNECTIONS);
        connectionManager.setDefaultMaxPerRoute(DEFAULT_MAX_PER_ROUTE);
        connectionManager.setValidateAfterInactivity(VALIDATE_AFTER_INACTIVITY);

        ConnectionKeepAliveStrategy keepAliveStrategy = (response, context) -> {
            HeaderElementIterator it = new BasicHeaderElementIterator(
                    response.headerIterator(HTTP.CONN_KEEP_ALIVE));
            while (it.hasNext()) {
                HeaderElement he = it.nextElement();
                String param = he.getName();
                String value = he.getValue();
                if (value != null && param.equalsIgnoreCase("timeout")) {
                    return Long.parseLong(value) * 1000;
                }
            }
            return DEFAULT_KEEP_ALIVE_TIME;
        };

        httpClient = HttpClients.custom()
                .setConnectionManager(connectionManager)
                .setKeepAliveStrategy(keepAliveStrategy)
                .setDefaultRequestConfig(DEFAULT_REQUEST_CONFIG)
                .setRetryHandler((exception, executionCount, context) -> {
                    if (executionCount > 3) {
                        return false;
                    }
                    // 如果服务器丢掉了连接，那么就重试
                    return exception instanceof NoHttpResponseException;
                })
                .build();

        // 启动定时清理空闲连接的线程
        startIdleConnectionMonitor();
    }

    private static void startIdleConnectionMonitor() {
        Thread monitorThread = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    TimeUnit.SECONDS.sleep(30);
                    connectionManager.closeExpiredConnections();
                    connectionManager.closeIdleConnections(30, TimeUnit.SECONDS);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } catch (Exception e) {
                    logger.error("Exception while closing expired connections", e);
                }
            }
        });
        monitorThread.setDaemon(true);
        monitorThread.start();
    }

    /**
     * 发送GET请求
     */
    public static String doGet(String url) throws IOException {
        HttpGet httpGet = new HttpGet(url);

        try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
            HttpEntity entity = response.getEntity();
            if (entity != null) {
                return EntityUtils.toString(entity, StandardCharsets.UTF_8);
            }
        } catch (IOException e) {
            logger.error("Error executing GET request to {}: {}", url, e.getMessage());
            throw e;
        }
        return null;
    }

    /**
     * 发送POST请求
     */
    public static String doPost(String url, String jsonBody) throws IOException {
        HttpPost httpPost = new HttpPost(url);

        if (jsonBody != null) {
            StringEntity entity = new StringEntity(jsonBody, StandardCharsets.UTF_8);
            entity.setContentType("application/json");
            httpPost.setEntity(entity);
        }

        try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
            HttpEntity entity = response.getEntity();
            if (entity != null) {
                return EntityUtils.toString(entity, StandardCharsets.UTF_8);
            }
        } catch (IOException e) {
            logger.error("Error executing POST request to {}: {}", url, e.getMessage());
            throw e;
        }
        return null;
    }

    /**
     * 发送带自定义RequestConfig的GET请求
     */
    public static String doGet(String url, RequestConfig requestConfig) throws IOException {
        HttpGet httpGet = new HttpGet(url);
        httpGet.setConfig(requestConfig);

        try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
            HttpEntity entity = response.getEntity();
            if (entity != null) {
                return EntityUtils.toString(entity, StandardCharsets.UTF_8);
            }
        }
        return null;
    }

    /**
     * 发送带自定义RequestConfig的POST请求
     */
    public static String doPost(String url, String jsonBody, RequestConfig requestConfig) throws IOException {
        HttpPost httpPost = new HttpPost(url);
        httpPost.setConfig(requestConfig);

        if (jsonBody != null) {
            StringEntity entity = new StringEntity(jsonBody, StandardCharsets.UTF_8);
            entity.setContentType("application/json");
            httpPost.setEntity(entity);
        }

        try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
            HttpEntity entity = response.getEntity();
            if (entity != null) {
                return EntityUtils.toString(entity, StandardCharsets.UTF_8);
            }
        }
        return null;
    }

    /**
     * 创建自定义RequestConfig
     */
    public static RequestConfig createRequestConfig(int connectTimeout, int socketTimeout, int connectionRequestTimeout) {
        return RequestConfig.custom()
                .setConnectTimeout(connectTimeout)
                .setSocketTimeout(socketTimeout)
                .setConnectionRequestTimeout(connectionRequestTimeout)
                .build();
    }

    /**
     * 关闭连接池和客户端
     * 建议在应用程序关闭时调用
     */
    public static void close() {
        try {
            httpClient.close();
            connectionManager.close();
        } catch (IOException e) {
            logger.error("Error closing HttpClient", e);
        }
    }
}

```

使用示例：

```java
// 简单GET请求
String response = HttpClientUtil.doGet("http://example.com/api/data");

// 简单POST请求
String jsonBody = "{\"key\":\"value\"}";
String response = HttpClientUtil.doPost("http://example.com/api/data", jsonBody);

// 使用自定义超时的请求
RequestConfig customConfig = HttpClientUtil.createRequestConfig(3000, 5000, 2000);
String response = HttpClientUtil.doGet("http://example.com/api/data", customConfig);
```

这个静态工具类的特点：

1. 连接池优化：
    - 使用 PoolingHttpClientConnectionManager 管理连接池
    - 设置了最大连接数和每个路由的最大连接数
    - 包含了连接存活时间管理
    - 自动清理过期和空闲连接

2. 重试机制：
    - 对 NoHttpResponseException 异常进行重试
    - 最多重试3次

3. 性能优化：
    - 静态初始化，避免重复创建客户端
    - 使用守护线程定期清理过期连接
    - 可配置的连接和请求超时

4. 使用建议：
    - 在应用关闭时调用 `HttpClientUtil.close()`
    - 对于特殊需求，可以使用自定义的 RequestConfig
    - 注意异常处理

如果你的应用是 Spring Boot 应用，建议在某个配置类中添加：

```java
@Configuration
public class ApplicationConfig {
    @PreDestroy
    public void destroy() {
        HttpClientUtil.close();
    }
}
```

这样可以确保在应用关闭时正确释放资源。

主要改进：
1. 统一的连接池管理
2. 自动重试机制
3. 空闲连接清理
4. 可配置的超时设置
5. 异常处理和日志记录

这种方式既保持了静态工具类的使用便利性，又解决了连接池和资源管理的问题。我来修改 HttpClientUtil，添加对 HTTPS 的支持，并且忽略证书验证：

```java
package com.study.scheduler.utils;

import org.apache.http.HeaderElement;
import org.apache.http.HeaderElementIterator;
import org.apache.http.HttpEntity;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.conn.ConnectionKeepAliveStrategy;
import org.apache.http.conn.ssl.NoopHostnameVerifier;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.TrustStrategy;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.apache.http.message.BasicHeaderElementIterator;
import org.apache.http.protocol.HTTP;
import org.apache.http.protocol.HttpContext;
import org.apache.http.ssl.SSLContextBuilder;
import org.apache.http.util.EntityUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.net.ssl.SSLContext;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.X509Certificate;
import java.util.concurrent.TimeUnit;

public class HttpClientUtil {
    private static final Logger logger = LoggerFactory.getLogger(HttpClientUtil.class);

    private static final CloseableHttpClient httpClient;
    private static final CloseableHttpClient httpsClient;
    private static final PoolingHttpClientConnectionManager connectionManager;
    private static final PoolingHttpClientConnectionManager httpsConnectionManager;

    // 连接池配置
    private static final int MAX_TOTAL_CONNECTIONS = 100;
    private static final int DEFAULT_MAX_PER_ROUTE = 20;
    private static final int VALIDATE_AFTER_INACTIVITY = 2000;
    private static final int DEFAULT_KEEP_ALIVE_TIME = 20000;

    // 请求配置
    private static final RequestConfig DEFAULT_REQUEST_CONFIG = RequestConfig.custom()
            .setConnectTimeout(5000)
            .setSocketTimeout(10000)
            .setConnectionRequestTimeout(3000)
            .build();

    // 静态初始化
    static {
        try {
            // 创建SSL上下文，信任所有证书
            SSLContext sslContext = new SSLContextBuilder()
                    .loadTrustMaterial(null, new TrustStrategy() {
                        @Override
                        public boolean isTrusted(X509Certificate[] chain, String authType) {
                            return true; // 信任所有证书
                        }
                    }).build();

            // 创建SSL连接工厂
            SSLConnectionSocketFactory sslFactory = new SSLConnectionSocketFactory(
                    sslContext,
                    NoopHostnameVerifier.INSTANCE);

            // HTTP连接管理器
            connectionManager = new PoolingHttpClientConnectionManager();
            configureConnectionManager(connectionManager);

            // HTTPS连接管理器
            httpsConnectionManager = new PoolingHttpClientConnectionManager();
            configureConnectionManager(httpsConnectionManager);

            // 配置保活策略
            ConnectionKeepAliveStrategy keepAliveStrategy = createKeepAliveStrategy();

            // 创建HTTP客户端
            httpClient = HttpClients.custom()
                    .setConnectionManager(connectionManager)
                    .setKeepAliveStrategy(keepAliveStrategy)
                    .setDefaultRequestConfig(DEFAULT_REQUEST_CONFIG)
                    .setRetryHandler((exception, executionCount, context) -> {
                        if (executionCount > 3) {
                            return false;
                        }
                        return exception instanceof NoHttpResponseException;
                    })
                    .build();

            // 创建HTTPS客户端
            httpsClient = HttpClients.custom()
                    .setConnectionManager(httpsConnectionManager)
                    .setKeepAliveStrategy(keepAliveStrategy)
                    .setDefaultRequestConfig(DEFAULT_REQUEST_CONFIG)
                    .setSSLSocketFactory(sslFactory)
                    .setRetryHandler((exception, executionCount, context) -> {
                        if (executionCount > 3) {
                            return false;
                        }
                        return exception instanceof NoHttpResponseException;
                    })
                    .build();

            // 启动定时清理空闲连接的线程
            startIdleConnectionMonitor();

        } catch (NoSuchAlgorithmException | KeyStoreException | KeyManagementException e) {
            logger.error("Failed to initialize HTTPS client", e);
            throw new RuntimeException("Failed to initialize HTTPS client", e);
        }
    }

    private static void configureConnectionManager(PoolingHttpClientConnectionManager manager) {
        manager.setMaxTotal(MAX_TOTAL_CONNECTIONS);
        manager.setDefaultMaxPerRoute(DEFAULT_MAX_PER_ROUTE);
        manager.setValidateAfterInactivity(VALIDATE_AFTER_INACTIVITY);
    }

    private static ConnectionKeepAliveStrategy createKeepAliveStrategy() {
        return (response, context) -> {
            HeaderElementIterator it = new BasicHeaderElementIterator(
                    response.headerIterator(HTTP.CONN_KEEP_ALIVE));
            while (it.hasNext()) {
                HeaderElement he = it.nextElement();
                String param = he.getName();
                String value = he.getValue();
                if (value != null && param.equalsIgnoreCase("timeout")) {
                    return Long.parseLong(value) * 1000;
                }
            }
            return DEFAULT_KEEP_ALIVE_TIME;
        };
    }

    private static void startIdleConnectionMonitor() {
        Thread monitorThread = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    TimeUnit.SECONDS.sleep(30);
                    // 清理HTTP连接
                    connectionManager.closeExpiredConnections();
                    connectionManager.closeIdleConnections(30, TimeUnit.SECONDS);
                    // 清理HTTPS连接
                    httpsConnectionManager.closeExpiredConnections();
                    httpsConnectionManager.closeIdleConnections(30, TimeUnit.SECONDS);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } catch (Exception e) {
                    logger.error("Exception while closing expired connections", e);
                }
            }
        });
        monitorThread.setDaemon(true);
        monitorThread.start();
    }

    /**
     * 根据URL选择合适的HttpClient
     */
    private static CloseableHttpClient getHttpClient(String url) {
        return url.toLowerCase().startsWith("https://") ? httpsClient : httpClient;
    }

    /**
     * 发送GET请求
     */
    public static String doGet(String url) throws IOException {
        HttpGet httpGet = new HttpGet(url);

        try (CloseableHttpResponse response = getHttpClient(url).execute(httpGet)) {
            HttpEntity entity = response.getEntity();
            if (entity != null) {
                return EntityUtils.toString(entity, StandardCharsets.UTF_8);
            }
        } catch (IOException e) {
            logger.error("Error executing GET request to {}: {}", url, e.getMessage());
            throw e;
        }
        return null;
    }

    /**
     * 发送POST请求
     */
    public static String doPost(String url, String jsonBody) throws IOException {
        HttpPost httpPost = new HttpPost(url);

        if (jsonBody != null) {
            StringEntity entity = new StringEntity(jsonBody, StandardCharsets.UTF_8);
            entity.setContentType("application/json");
            httpPost.setEntity(entity);
        }

        try (CloseableHttpResponse response = getHttpClient(url).execute(httpPost)) {
            HttpEntity entity = response.getEntity();
            if (entity != null) {
                return EntityUtils.toString(entity, StandardCharsets.UTF_8);
            }
        } catch (IOException e) {
            logger.error("Error executing POST request to {}: {}", url, e.getMessage());
            throw e;
        }
        return null;
    }

    /**
     * 创建自定义RequestConfig
     */
    public static RequestConfig createRequestConfig(int connectTimeout, int socketTimeout, int connectionRequestTimeout) {
        return RequestConfig.custom()
                .setConnectTimeout(connectTimeout)
                .setSocketTimeout(socketTimeout)
                .setConnectionRequestTimeout(connectionRequestTimeout)
                .build();
    }

    /**
     * 关闭连接池和客户端
     */
    public static void close() {
        try {
            httpClient.close();
            httpsClient.close();
            connectionManager.close();
            httpsConnectionManager.close();
        } catch (IOException e) {
            logger.error("Error closing HttpClient", e);
        }
    }
}

```

主要改进：

1. 分别创建了 HTTP 和 HTTPS 的客户端和连接池
2. 对 HTTPS 请求：
    - 创建了信任所有证书的 SSLContext
    - 使用 NoopHostnameVerifier 跳过主机名验证
    - 自动根据 URL 选择合适的客户端

使用方式保持不变：

```java
// HTTP请求
String response1 = HttpClientUtil.doGet("http://example.com/api/data");

// HTTPS请求（自动忽略证书验证）
String response2 = HttpClientUtil.doGet("https://example.com/api/data");

// POST请求
String jsonBody = "{\"key\":\"value\"}";
String response3 = HttpClientUtil.doPost("https://example.com/api/data", jsonBody);
```

注意事项：

1. 安全性警告：
    - 忽略证书验证可能存在安全风险
    - 仅建议在开发测试环境使用，或者确实需要访问自签名证书的服务器时使用

2. 性能优化：
    - 分别维护 HTTP 和 HTTPS 的连接池
    - 自动清理过期连接
    - 保持连接复用

3. 资源管理：
    - 确保在应用关闭时调用 `close()` 方法
    - 监控线程使用守护线程，不会阻止 JVM 退出

如果需要在 Spring Boot 应用中使用，仍然建议添加关闭钩子：

```java
@Configuration
public class ApplicationConfig {
    @PreDestroy
    public void destroy() {
        HttpClientUtil.close();
    }
}
```好的，我来修改代码，完全禁用所有 HTTPS 证书验证：

```java
package com.study.scheduler.utils;

import org.apache.http.HttpEntity;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.conn.ssl.NoopHostnameVerifier;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.apache.http.ssl.TrustStrategy;
import org.apache.http.util.EntityUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;
import java.util.concurrent.TimeUnit;

public class HttpClientUtil {
    private static final Logger logger = LoggerFactory.getLogger(HttpClientUtil.class);

    private static final CloseableHttpClient httpClient;
    private static final PoolingHttpClientConnectionManager connectionManager;
    
    private static final int MAX_TOTAL_CONNECTIONS = 100;
    private static final int DEFAULT_MAX_PER_ROUTE = 20;
    private static final int VALIDATE_AFTER_INACTIVITY = 2000;
    
    private static final RequestConfig DEFAULT_REQUEST_CONFIG = RequestConfig.custom()
            .setConnectTimeout(5000)
            .setSocketTimeout(10000)
            .setConnectionRequestTimeout(3000)
            .build();

    static {
        try {
            // 创建一个不验证证书的TrustManager
            TrustManager[] trustAllCerts = new TrustManager[]{
                new X509TrustManager() {
                    public X509Certificate[] getAcceptedIssuers() {
                        return null;
                    }
                    public void checkClientTrusted(X509Certificate[] certs, String authType) {
                    }
                    public void checkServerTrusted(X509Certificate[] certs, String authType) {
                    }
                }
            };

            // 创建SSLContext
            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(null, trustAllCerts, new SecureRandom());

            // 创建SSLConnectionSocketFactory
            SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(
                    sslContext,
                    NoopHostnameVerifier.INSTANCE);

            // 配置连接管理器
            connectionManager = new PoolingHttpClientConnectionManager();
            connectionManager.setMaxTotal(MAX_TOTAL_CONNECTIONS);
            connectionManager.setDefaultMaxPerRoute(DEFAULT_MAX_PER_ROUTE);
            connectionManager.setValidateAfterInactivity(VALIDATE_AFTER_INACTIVITY);

            // 创建HttpClient
            httpClient = HttpClients.custom()
                    .setSSLSocketFactory(sslsf)
                    .setConnectionManager(connectionManager)
                    .setDefaultRequestConfig(DEFAULT_REQUEST_CONFIG)
                    .setRetryHandler((exception, executionCount, context) -> {
                        if (executionCount > 3) {
                            return false;
                        }
                        return exception instanceof NoHttpResponseException;
                    })
                    .build();

            // 启动清理空闲连接的线程
            startIdleConnectionMonitor();

        } catch (NoSuchAlgorithmException | KeyManagementException e) {
            logger.error("Failed to initialize HTTPS client", e);
            throw new RuntimeException("Failed to initialize HTTPS client", e);
        }
    }

    private static void startIdleConnectionMonitor() {
        Thread monitorThread = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    TimeUnit.SECONDS.sleep(30);
                    connectionManager.closeExpiredConnections();
                    connectionManager.closeIdleConnections(30, TimeUnit.SECONDS);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } catch (Exception e) {
                    logger.error("Exception while closing expired connections", e);
                }
            }
        });
        monitorThread.setDaemon(true);
        monitorThread.start();
    }

    /**
     * 发送GET请求
     */
    public static String doGet(String url) throws IOException {
        HttpGet httpGet = new HttpGet(url);
        
        try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
            HttpEntity entity = response.getEntity();
            if (entity != null) {
                return EntityUtils.toString(entity, StandardCharsets.UTF_8);
            }
        } catch (IOException e) {
            logger.error("Error executing GET request to {}: {}", url, e.getMessage());
            throw e;
        }
        return null;
    }

    /**
     * 发送POST请求
     */
    public static String doPost(String url, String jsonBody) throws IOException {
        HttpPost httpPost = new HttpPost(url);
        
        if (jsonBody != null) {
            StringEntity entity = new StringEntity(jsonBody, StandardCharsets.UTF_8);
            entity.setContentType("application/json");
            httpPost.setEntity(entity);
        }
        
        try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
            HttpEntity entity = response.getEntity();
            if (entity != null) {
                return EntityUtils.toString(entity, StandardCharsets.UTF_8);
            }
        } catch (IOException e) {
            logger.error("Error executing POST request to {}: {}", url, e.getMessage());
            throw e;
        }
        return null;
    }

    /**
     * 关闭连接池和客户端
     */
    public static void close() {
        try {
            httpClient.close();
            connectionManager.close();
        } catch (IOException e) {
            logger.error("Error closing HttpClient", e);
        }
    }
}

```

主要改动：

1. 完全禁用证书验证：
    - 创建了一个空的 TrustManager，接受所有证书
    - 使用 NoopHostnameVerifier 禁用主机名验证

2. 简化了代码结构：
    - 不再区分 HTTP 和 HTTPS 客户端
    - 使用单一的连接池管理器
    - 移除了不必要的配置

使用方式：

```java
// HTTP请求
String response1 = HttpClientUtil.doGet("http://example.com/api/data");

// HTTPS请求（完全不验证证书）
String response2 = HttpClientUtil.doGet("https://example.com/api/data");

// POST请求
String jsonBody = "{\"key\":\"value\"}";
String response3 = HttpClientUtil.doPost("https://example.com/api/data", jsonBody);
```

重要注意事项：
1. 这种方式完全禁用了 HTTPS 证书验证，仅建议在以下场景使用：
    - 开发测试环境
    - 访问使用自签名证书的内部系统
    - 确实需要访问不受信任证书的服务器

2. 在生产环境中，建议谨慎使用此方式，最好：
    - 使用正式的 SSL 证书
    - 将自签名证书导入信任库
    - 配置正确的证书验证机制

3. 如果在 Spring Boot 中使用，添加关闭钩子：

```java
@Configuration
public class ApplicationConfig {
    @PreDestroy
    public void destroy() {
        HttpClientUtil.close();
    }
}
```

这个版本应该能解决 "unable to find valid certification path to requested target" 错误，因为它完全跳过了证书验证过程。
让我们做一个最彻底的禁用SSL验证的版本，同时添加一些调试日志来查看具体问题：

```java
package com.study.scheduler.utils;

import org.apache.http.HttpEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.conn.ssl.NoopHostnameVerifier;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.TrustStrategy;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.ssl.SSLContextBuilder;
import org.apache.http.util.EntityUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.net.ssl.*;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

public class HttpClientUtil {
    private static final Logger logger = LoggerFactory.getLogger(HttpClientUtil.class);
    private static CloseableHttpClient httpClient;

    static {
        disableSSLVerification();
        initHttpClient();
    }

    private static void disableSSLVerification() {
        try {
            // Create a trust manager that does not validate certificate chains
            TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        public X509Certificate[] getAcceptedIssuers() {
                            return null;
                        }

                        public void checkClientTrusted(X509Certificate[] certs, String authType) {
                        }

                        public void checkServerTrusted(X509Certificate[] certs, String authType) {
                        }
                    }
            };

            // Install the all-trusting trust manager
            SSLContext sc = SSLContext.getInstance("SSL");
            sc.init(null, trustAllCerts, new SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

            // Create all-trusting host name verifier
            HostnameVerifier allHostsValid = new HostnameVerifier() {
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }
            };

            // Install the all-trusting host verifier
            HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
        } catch (NoSuchAlgorithmException | KeyManagementException e) {
            logger.error("Failed to disable SSL verification", e);
        }
    }

    private static void initHttpClient() {
        try {
            SSLContextBuilder builder = new SSLContextBuilder();
            builder.loadTrustMaterial(null, new TrustStrategy() {
                @Override
                public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                    return true;
                }
            });

            SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(
                    builder.build(),
                    new String[]{"TLSv1.2", "TLSv1.1", "TLSv1", "SSLv3"},
                    null,
                    NoopHostnameVerifier.INSTANCE);

            httpClient = HttpClients.custom()
                    .setSSLSocketFactory(sslsf)
                    .build();

        } catch (NoSuchAlgorithmException | KeyStoreException | KeyManagementException e) {
            logger.error("Failed to initialize HttpClient", e);
            throw new RuntimeException(e);
        }
    }

    /**
     * 发送GET请求，带详细日志
     */
    public static String doGet(String url) throws IOException {
        logger.info("Sending GET request to: {}", url);

        try {
            HttpGet httpGet = new HttpGet(url);
            // 添加一些通用headers
            httpGet.addHeader("User-Agent", "Mozilla/5.0");
            httpGet.addHeader("Accept", "*/*");

            logger.debug("Request headers: {}", (Object) httpGet.getAllHeaders());

            try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                logger.info("Response status: {}", response.getStatusLine());

                HttpEntity entity = response.getEntity();
                if (entity != null) {
                    String responseBody = EntityUtils.toString(entity, StandardCharsets.UTF_8);
                    logger.debug("Response body: {}", responseBody);
                    return responseBody;
                } else {
                    logger.warn("No response entity");
                    return null;
                }
            }
        } catch (Exception e) {
            logger.error("Error executing GET request to {}", url, e);
            throw e;
        }
    }

    /**
     * 发送POST请求
     */
    public static String doPost(String url, String jsonBody) throws IOException {
        logger.info("Sending POST request to: {}", url);

        HttpPost httpPost = new HttpPost(url);
        // 添加一些通用headers
        httpPost.addHeader("User-Agent", "Mozilla/5.0");
        httpPost.addHeader("Accept", "*/*");

        if (jsonBody != null) {
            StringEntity entity = new StringEntity(jsonBody, StandardCharsets.UTF_8);
            entity.setContentType("application/json");
            httpPost.setEntity(entity);
        }

        try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
            logger.info("Response status: {}", response.getStatusLine());

            HttpEntity entity = response.getEntity();
            if (entity != null) {
                String responseBody = EntityUtils.toString(entity, StandardCharsets.UTF_8);
                logger.debug("Response body: {}", responseBody);
                return responseBody;
            }
        } catch (Exception e) {
            logger.error("Error executing POST request to {}", url, e);
            throw e;
        }
        return null;
    }

    /**
     * 使用java原生URLConnection发送GET请求（备用方法）
     */
    public static String doGetWithUrlConnection(String urlStr) {
        try {
            URL url = new URL(urlStr);
            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
            conn.setRequestMethod("GET");
            conn.setRequestProperty("User-Agent", "Mozilla/5.0");

            logger.info("Response code: {}", conn.getResponseCode());

            try (java.io.BufferedReader in = new java.io.BufferedReader(
                    new java.io.InputStreamReader(conn.getInputStream()))) {
                String inputLine;
                StringBuilder response = new StringBuilder();
                while ((inputLine = in.readLine()) != null) {
                    response.append(inputLine);
                }
                return response.toString();
            }
        } catch (Exception e) {
            logger.error("Error in URLConnection GET request", e);
            return null;
        }
    }
}

```

这个版本做了以下改进：

1. 双重SSL禁用：
    - 同时禁用了 HttpsURLConnection 和 HttpClient 的 SSL 验证
    - 添加了所有可能的 TLS 版本支持

2. 增加了详细的日志：
    - 记录请求和响应的详细信息
    - 记录所有可能的错误

3. 添加了更多的请求头：
    - 模拟浏览器的 User-Agent
    - 添加通用的 Accept 头

4. 提供了备用方法：
    - 使用 java.net.URLConnection 的备用实现

使用方式：

```java
try {
    // 方式1：使用HttpClient
    String response = HttpClientUtil.doGet("https://your-nginx-server/api");
    System.out.println(response);
    
    // 如果上面不行，可以尝试备用方法
    String response2 = HttpClientUtil.doGetWithUrlConnection("https://your-nginx-server/api");
    System.out.println(response2);
    
} catch (Exception e) {
    e.printStackTrace();
}
```

请尝试使用这个版本，它应该能处理任何SSL证书问题。如果还有问题，请查看日志输出，看看具体是在哪一步出现了错误。

你也可以尝试在代码中打印更多信息来调试：

```java
// 在调用前打印SSL相关信息
System.out.println("Default SSL context: " + SSLContext.getDefault());
System.out.println("Default SSLSocketFactory: " + HttpsURLConnection.getDefaultSSLSocketFactory());
System.out.println("Default HostnameVerifier: " + HttpsURLConnection.getDefaultHostnameVerifier());
```

如果还是不行，可以尝试：

1. 检查URL是否正确（包括协议、端口等）
2. 确认服务器的SSL证书配置
3. 检查是否有代理设置影响
4. 尝试用备用方法 `doGetWithUrlConnection`

记得查看日志输出，这样可以看到具体在哪一步出现了问题。
我帮你整理一个完整版，包含详细日志和连接保活：

```java
package com.study.scheduler.utils;

import org.apache.http.HeaderElement;
import org.apache.http.HeaderElementIterator;
import org.apache.http.HttpEntity;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.conn.ConnectionKeepAliveStrategy;
import org.apache.http.conn.ssl.NoopHostnameVerifier;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.apache.http.message.BasicHeaderElementIterator;
import org.apache.http.protocol.HTTP;
import org.apache.http.util.EntityUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.net.ssl.*;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;
import java.util.concurrent.TimeUnit;

public class HttpClientUtil {
    private static final Logger logger = LoggerFactory.getLogger(HttpClientUtil.class);

    private static CloseableHttpClient httpClient;
    private static PoolingHttpClientConnectionManager connectionManager;

    // 连接池配置
    private static final int MAX_TOTAL_CONNECTIONS = 200;
    private static final int MAX_PER_ROUTE = 20;
    private static final int VALIDATE_AFTER_INACTIVITY_MS = 5000;
    private static final int DEFAULT_KEEP_ALIVE_TIME_MS = 20 * 1000;
    private static final int CONNECTION_TIMEOUT_MS = 5000;
    private static final int SOCKET_TIMEOUT_MS = 15000;
    private static final int REQUEST_TIMEOUT_MS = 5000;

    static {
        init();
    }

    private static void init() {
        try {
            logger.info("Initializing HttpClientUtil...");

            // 1. 配置全局的SSL上下文
            configureGlobalSSL();

            // 2. 创建SSL连接工厂
            SSLConnectionSocketFactory sslFactory = createSSLConnectionFactory();

            // 3. 创建和配置连接管理器
            connectionManager = createConnectionManager();

            // 4. 创建保活策略
            ConnectionKeepAliveStrategy keepAliveStrategy = createKeepAliveStrategy();

            // 5. 创建请求配置
            RequestConfig requestConfig = createRequestConfig();

            // 6. 创建HttpClient
            httpClient = createHttpClient(sslFactory, keepAliveStrategy, requestConfig);

            // 7. 启动空闲连接监控
            startIdleConnectionMonitor();

            logger.info("HttpClientUtil initialized successfully");
        } catch (Exception e) {
            logger.error("Failed to initialize HttpClientUtil", e);
            throw new RuntimeException("Failed to initialize HttpClientUtil", e);
        }
    }

    private static void configureGlobalSSL() {
        try {
            // 创建信任所有证书的信任管理器
            TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        public X509Certificate[] getAcceptedIssuers() {
                            return null;
                        }

                        public void checkClientTrusted(X509Certificate[] certs, String authType) {
                        }

                        public void checkServerTrusted(X509Certificate[] certs, String authType) {
                        }
                    }
            };

            // 配置SSL上下文
            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(null, trustAllCerts, new SecureRandom());
            SSLContext.setDefault(sslContext);
            HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
            HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> true);

            logger.info("Global SSL configuration completed");
        } catch (Exception e) {
            logger.error("Failed to configure global SSL", e);
            throw new RuntimeException(e);
        }
    }

    private static SSLConnectionSocketFactory createSSLConnectionFactory() throws NoSuchAlgorithmException, KeyManagementException {
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(null, new TrustManager[]{
                new X509TrustManager() {
                    public X509Certificate[] getAcceptedIssuers() {
                        return null;
                    }

                    public void checkClientTrusted(X509Certificate[] certs, String authType) {
                    }

                    public void checkServerTrusted(X509Certificate[] certs, String authType) {
                    }
                }
        }, new SecureRandom());

        logger.info("Created SSL Connection Factory");
        return new SSLConnectionSocketFactory(
                sslContext,
                new String[]{"TLSv1", "TLSv1.1", "TLSv1.2"},
                null,
                NoopHostnameVerifier.INSTANCE);
    }

    private static PoolingHttpClientConnectionManager createConnectionManager() {
        PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();
        cm.setMaxTotal(MAX_TOTAL_CONNECTIONS);
        cm.setDefaultMaxPerRoute(MAX_PER_ROUTE);
        cm.setValidateAfterInactivity(VALIDATE_AFTER_INACTIVITY_MS);

        logger.info("Created Connection Manager with maxTotal={}, maxPerRoute={}",
                MAX_TOTAL_CONNECTIONS, MAX_PER_ROUTE);
        return cm;
    }

    private static ConnectionKeepAliveStrategy createKeepAliveStrategy() {
        return (response, context) -> {
            HeaderElementIterator it = new BasicHeaderElementIterator(
                    response.headerIterator(HTTP.CONN_KEEP_ALIVE));
            while (it.hasNext()) {
                HeaderElement he = it.nextElement();
                String param = he.getName();
                String value = he.getValue();
                if (value != null && param.equalsIgnoreCase("timeout")) {
                    return Long.parseLong(value) * 1000;
                }
            }
            return DEFAULT_KEEP_ALIVE_TIME_MS;
        };
    }

    private static RequestConfig createRequestConfig() {
        return RequestConfig.custom()
                .setConnectTimeout(CONNECTION_TIMEOUT_MS)
                .setSocketTimeout(SOCKET_TIMEOUT_MS)
                .setConnectionRequestTimeout(REQUEST_TIMEOUT_MS)
                .build();
    }

    private static CloseableHttpClient createHttpClient(
            SSLConnectionSocketFactory sslFactory,
            ConnectionKeepAliveStrategy keepAliveStrategy,
            RequestConfig requestConfig) {
        return HttpClients.custom()
                .setSSLSocketFactory(sslFactory)
                .setConnectionManager(connectionManager)
                .setKeepAliveStrategy(keepAliveStrategy)
                .setDefaultRequestConfig(requestConfig)
                .build();
    }

    private static void startIdleConnectionMonitor() {
        Thread monitorThread = new Thread(() -> {
            try {
                while (!Thread.currentThread().isInterrupted()) {
                    synchronized (connectionManager) {
                        logger.debug("Closing expired and idle connections...");
                        connectionManager.closeExpiredConnections();
                        connectionManager.closeIdleConnections(30, TimeUnit.SECONDS);
                    }
                    Thread.sleep(30000);
                }
            } catch (InterruptedException e) {
                logger.warn("Connection monitor thread interrupted", e);
                Thread.currentThread().interrupt();
            }
        });
        monitorThread.setDaemon(true);
        monitorThread.start();
        logger.info("Started idle connection monitor thread");
    }

    public static String doGet(String url) throws IOException {
        logger.info("Executing GET request to: {}", url);
        long startTime = System.currentTimeMillis();

        try {
            HttpGet httpGet = new HttpGet(url);
            httpGet.setHeader("User-Agent", "Mozilla/5.0");
            httpGet.setHeader("Accept", "*/*");

            logger.debug("Request headers: {}", (Object[]) httpGet.getAllHeaders());

            try (CloseableHttpResponse response = httpClient.execute(httpGet)) {
                int statusCode = response.getStatusLine().getStatusCode();
                logger.info("Response status code: {}", statusCode);
                logger.debug("Response headers: {}", (Object[]) response.getAllHeaders());

                HttpEntity entity = response.getEntity();
                if (entity != null) {
                    String responseBody = EntityUtils.toString(entity, StandardCharsets.UTF_8);
                    logger.debug("Response body: {}", responseBody);
                    return responseBody;
                } else {
                    logger.warn("No response entity");
                    return null;
                }
            }
        } catch (Exception e) {
            logger.error("Error executing GET request to {}: {}", url, e.getMessage(), e);
            throw e;
        } finally {
            long endTime = System.currentTimeMillis();
            logger.info("Request completed in {} ms", endTime - startTime);
        }
    }

    public static String doPost(String url, String jsonBody) throws IOException {
        logger.info("Executing POST request to: {}", url);
        long startTime = System.currentTimeMillis();

        try {
            HttpPost httpPost = new HttpPost(url);
            httpPost.setHeader("Content-Type", "application/json");
            httpPost.setHeader("User-Agent", "Mozilla/5.0");
            httpPost.setHeader("Accept", "*/*");

            if (jsonBody != null) {
                StringEntity entity = new StringEntity(jsonBody, StandardCharsets.UTF_8);
                httpPost.setEntity(entity);
                logger.debug("Request body: {}", jsonBody);
            }

            try (CloseableHttpResponse response = httpClient.execute(httpPost)) {
                int statusCode = response.getStatusLine().getStatusCode();
                logger.info("Response status code: {}", statusCode);
                logger.debug("Response headers: {}", (Object[]) response.getAllHeaders());

                HttpEntity entity = response.getEntity();
                if (entity != null) {
                    String responseBody = EntityUtils.toString(entity, StandardCharsets.UTF_8);
                    logger.debug("Response body: {}", responseBody);
                    return responseBody;
                } else {
                    logger.warn("No response entity");
                    return null;
                }
            }
        } catch (Exception e) {
            logger.error("Error executing POST request to {}: {}", url, e.getMessage(), e);
            throw e;
        } finally {
            long endTime = System.currentTimeMillis();
            logger.info("Request completed in {} ms", endTime - startTime);
        }
    }

    public static void close() {
        try {
            logger.info("Closing HttpClientUtil resources...");
            if (httpClient != null) {
                httpClient.close();
            }
            if (connectionManager != null) {
                connectionManager.close();
            }
            logger.info("HttpClientUtil resources closed successfully");
        } catch (IOException e) {
            logger.error("Error closing HttpClientUtil resources", e);
        }
    }
}

```

使用方式：

```java
try {
    // 开启SSL调试日志（可选）
    System.setProperty("javax.net.debug", "ssl,handshake");
    
    // 发送GET请求
    String response = HttpClientUtil.doGet("https://your-server/api");
    System.out.println(response);
    
} catch (Exception e) {
    e.printStackTrace();
}

// 在应用关闭时
HttpClientUtil.close();
```

在 application.properties 或 application.yml 中配置日志级别：

```yaml
logging:
  level:
    com.study.scheduler.utils.HttpClientUtil: DEBUG
    org.apache.http: DEBUG
```

这个版本的特点：

1. 完整的日志记录
    - 请求和响应的详细信息
    - 连接池状态
    - 执行时间统计
    - SSL相关问题

2. 连接池优化
    - 自动管理连接
    - 定期清理过期连接
    - 连接保活策略

3. SSL处理
    - 完全禁用证书验证
    - 支持多个TLS版本
    - 全局SSL配置

4. 异常处理
    - 详细的错误日志
    - 完整的异常堆栈

5. 性能优化
    - 连接复用
    - 请求超时控制
    - 资源自动清理

如果还遇到SSL问题，通过详细的日志你可以看到具体是在哪一步出现了问题，便于进一步调试和解决。